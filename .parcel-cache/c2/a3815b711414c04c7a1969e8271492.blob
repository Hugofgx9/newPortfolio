"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _gsap = _interopRequireDefault(require("gsap"));

var _interaction = _interopRequireDefault(require("./interaction2"));

var _vShader = _interopRequireDefault(require("../glsl/vShader2.glsl"));

var _fShader = _interopRequireDefault(require("../glsl/fShader.glsl"));

var _hupsylon = _interopRequireDefault(require("url:../img/hupsylon.png"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Planes {
  constructor(scene, sceneCtx) {
    this.scene = scene;
    this.sceneCtx = sceneCtx;
    this.baseWidth = 160;
    this.margin = 20;
    this.clock = this.sceneCtx.clock;
    this.initMethods();
    this.createPlanes();
    new _interaction.default(this.scene, this.sceneCtx, this.planes, this);
  }

  initMethods() {
    // make simple
    //  to gsap matrix;
    THREE.Mesh.prototype.gsapMatrix = function (time, opts = {}) {
      let matrixElement = this.matrix.elements[opts.index];
      let targetValue = opts.to;
      let initValue = {
        value: matrixElement
      };
      let delay = opts.delay || '';
      let ease = opts.ease || '';
      let onStart = opts.onStart || '';
      let onComplete = opts.onComplete || '';

      _gsap.default.to(initValue, time, {
        value: targetValue,
        delay,
        ease,
        onStart,
        onComplete,
        onUpdate: () => {
          this.matrix.elements[opts.index] = initValue.value;
        }
      });
    };

    THREE.Group.prototype.gsapMatrix = function (time, opts = {}) {
      let matrixElement = this.matrix.elements[opts.index];
      let targetValue = opts.to;
      let initValue = {
        value: matrixElement
      };
      let delay = opts.delay || '';
      let ease = opts.ease || '';
      let onStart = opts.onStart || '';
      let onComplete = opts.onComplete || '';

      _gsap.default.to(initValue, time, {
        value: targetValue,
        delay,
        ease,
        onStart,
        onComplete,
        onUpdate: () => {
          this.matrix.elements[opts.index] = initValue.value;
        }
      });
    };
  }

  createPlanes() {
    this.planes = [];
    this.planeGroup = new THREE.Group();

    for (let i in Array(5).fill()) {
      let planeWrapper = new THREE.Group();
      let loader = new THREE.TextureLoader();
      let img = loader.load(_hupsylon.default);
      let geometry = new THREE.PlaneGeometry(this.baseWidth, 400, 100, 100);
      let material = new THREE.ShaderMaterial({
        uniforms: {
          u_time: {
            type: 'f',
            value: 0
          },
          u_offsetPos: {
            type: 'f',
            value: 0
          },
          u_scale: {
            type: 'vec2',
            value: new THREE.Vector2(1, 1)
          },
          u_skew: {
            type: 'vec2',
            value: new THREE.Vector2(0, 0)
          },
          u_texture1: {
            type: 't',
            value: img
          }
        },
        vertexShader: _vShader.default,
        fragmentShader: _fShader.default,
        defines: {
          // tofixed(1) tronque le nombre avec 1 nombre aprÃ¨s la virgule
          PR: window.devicePixelRatio.toFixed(1)
        },
        side: THREE.DoubleSide
      });
      let plane = new THREE.Mesh(geometry, material);
      let posX = i * (this.baseWidth + this.margin);
      planeWrapper.add(plane);
      this.planes.push({
        mesh: plane,
        wrapper: planeWrapper,
        isOpen: false,
        basePos: posX,
        offset: 0
      });
      this.planeGroup.add(planeWrapper);
      plane.matrixAutoUpdate = false;
      planeWrapper.matrixAutoUpdate = false; //skewX

      planeWrapper.gsapMatrix(2, {
        index: 4,
        to: Math.tan(0.4)
      }); //translateX

      planeWrapper.gsapMatrix(0, {
        index: 12,
        to: posX
      });
    }

    this.scene.add(this.planeGroup); //this.centerObject(this.planeGroup);

    this.scrollOffset = 0;
  }

  onWheel(e) {
    _gsap.default.to(this.planeGroup.position, 0.5, {
      x: '+=' + e.deltaY * 0.33,
      ease: 'power2.out'
    });

    this.scrollOffset += e.deltaY * 0.0006;
    this.planes.forEach(plane => {
      _gsap.default.to(plane.mesh.material.uniforms.u_offsetPos, 0.5, {
        value: this.scrollOffset.toFixed(2),
        ease: 'power2.out'
      });

      _gsap.default.to(plane, 0.5, {
        offset: this.scrollOffset.toFixed(2),
        ease: 'power2.out'
      }); //plane.material.uniforms.u_offsetPos.value = this.offset.toFixed(2);

    });
  }

  update() {
    this.planes.forEach((plane, i) => {
      //plane.material.uniforms.u_time.value = i * 0.5;
      let time = this.clock.getElapsedTime() * 0.2 + i * (Math.PI / 5);
      let wavyValue = this.wavy(time, 1.5, 30., plane.offset); //translateY

      plane.mesh.matrix.elements[13] = wavyValue; //translateX trigo
      //plane.mesh.matrix.elements[12] = wavyValue * Math.tan(0.4);

      plane.mesh.material.uniforms.u_time.value = time;
    });
  }

  wavy(time, speed, amp, offset) {
    return Math.cos((time + offset) * speed) * amp;
  }

}

exports.default = Planes;